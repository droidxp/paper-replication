\section{Background and related works}

%\kn{This section starts abrupt. We should have a line that says what concepts we introduce on a high level. Also, I feel "sandbox" itself should be one of the backgrounds and have a textbf after the introductory line.}

In this section, we introduce the concepts and terminology that are necessary to understand the remainder of this paper. First, Section~\ref{sec:sandbox} introduces some background information about the use of \emph{sandboxes} to protect invalid access to sensitive resources. After that, in Section~\ref{sec:android-sandbox} we review the mining sandbox approach for detecting malicious behavior in Android apps. Finally, Section~\ref{sec:taint} presents some background information about taint analysis.

\subsection{The Sandbox Approach for Protecting Resources}\label{sec:sandbox}

A \emph{sandbox} is an isolated environment on an electronic device within which applications cannot affect other programs outside its boundaries, like the file system, the network, or other device data~\cite{DBLP:journals/peerj-cs/MaassSCS16}. Sandboxes enable testing and execution of unsafe or untested code, possible malware, without worrying about the integrity of the electronic device that runs the application~\cite{DBLP:conf/esorics/BordoniCS17}. This need might arise in a variety of situations, such as when executing software input by untrusted users, in malware analysis, or even as a security mechanism in case a trusted system gets compromised~\cite{DBLP:journals/peerj-cs/MaassSCS16}.
A sandbox environment must be able to shield the host machine or operating system from any damages caused by third-party software. Thus, a sandbox environment should have the minimum requirements to run programs (make sure the program will not impact resources outside the sandbox), and make sure it will never assign the program greater privileges than it should have, working with the principle of \emph{least privilege}, giving permissions to users according to their needs, i.e., giving them no more power than needed to successfully perform their task. This principle prevents escalating privileges and unauthorized access to resources, thereby improving the system's overall reliability.

Within the Android ecosystem, least privilege is realized through sandboxing process, where apps never access the data of other apps, and an app just accesses user resources, like contacts and location, through specific APIs (Application Programming Interface), which are in-turn guarded by permissions. Google Play Store is the primary market source for Android apps, and has a flexible policy regarding the apps' publishment process. Therefore, every month administrators remove several Android apps from the Play Store because of issues related to spyware and other types of malware \cite{DBLP:conf/msr/WangLL0X18}. For security reasons, Google Play lists each app with its requested permissions. However, many malicious apps usually ask for more permissions than their APIs normally would require~\cite{DBLP:conf/ccs/FeltCHSW11}. Those permissions are presented to the user during a new app's installation, since Android version 6, but most users are careless since they are only interested in the end product~\cite{DBLP:conf/soups/FeltHEHCW12}. 

Nowadays, malware becomes more stealthy and hackers learn how to avoid anti-virus signature checks, for instance by obfuscating calls to native code that is allowed to make system calls~\cite{DBLP:journals/corr/abs-2002-04540} or conducting side attacks to make system calls from a benign app.

\subsection{Mining Android Sandbox}\label{sec:android-sandbox}

The mining Android sandbox approach~\cite{DBLP:conf/icse/JamrozikSZ16} relies on test generator tools to explore an Android app's dynamic behavior, and thus mine a set of sensitive resources the app needs. The sandbox uses this set of sensitive APIs to ensure the app execution's security by restricting the resources that are allowed to use. The mining sandbox approach works in two phases. In the first, named exploratory phase, a practitioner uses test generator tools to execute a benign version of an app and record the set of sensitive APIs the app calls. In the second phase, named execution, the sandbox constraints the app to access only the sensitive APIs mined in the first phase. Accordingly, the sandbox ensures that a malicious app could not call any sensitive API, besides those calls to APIs recorded in the first phase.

The idea of automatically mining software resources or components to infer behavior is not new, and has been discussed before. For instance, Whaley et al.~\cite{DBLP:conf/issta/WhaleyML02} combine dynamic and static analysis for API mining and so infer program behavior based on an usage example of Java classes. Ammons et al.~\cite{DBLP:conf/popl/AmmonsBL02} propose a machine learning approach, called specification mining, to discover temporal and data-dependence relationships that a program follows when interacting with an API or abstract data types.

The main purpose of a test generator tool is to program crashes or bugs in general. Nonetheless, it is also possible to use test generator tools to explore program behavior (dynamic analysis), and thus assist in the task of building sandboxes. Regarding test generator tools used for mining Android sandboxes, Jamrozik et al~\cite{DBLP:conf/icse/JamrozikZ16} proposed DroidMate, a test generation tool that implements a pseudo-random graphical user interface (GUI) exploration strategy, and was the first approach to leverage test generation to extract sandbox rules from apps. Li et al.~\cite{DBLP:conf/icse/LiYGC17} proposed DroidBot, a test generator tool that explores sensitive resources access from Android apps, following a model-based exploration strategy. In their work, the authors present a comparison between DroidBot and Monkey~\cite{Monkey} regarding malware analysis and show that DroidBot can trigger several sensitive calls more often than Monkey. Sensitive calls in the Android context occurs when an Android app functionality can result in accessing or leaking of Android users' sensitive data. Examples of sensitive calls access user location or network information. Humanoid is another test generator tool for Android~\cite{DBLP:conf/kbse/LiY0C19}---actually a DroidBot evolution. It is also a GUI test generator that learning how humans interact with Android apps. In contrary to random input generators, Humanoid uses a learned model to generate human-like test inputs, and prioritize the possible interactions on a GUI, according to their importance.


Bao et al.~\cite{DBLP:conf/wcre/BaoLL18} present a comparative study test generator tools to identify malicious behavior using the mining sandboxes approach. Their study indicates that the tools were efficient in identifying at most $70$\% of the malware in a specific dataset and also reports that after, combining all test generator tools, it was possible to detect $75.49$\% of malicious behavior explored ($77$ among $102$). However, this study did not focus on the possible interference of static analysis in the final result, since this study used DroidFax~\cite{DBLP:conf/icsm/CaiR17a} to instrument the apps, though, as we discuss in this paper, DroidFax also performs a static analysis of the apps whose results complement the dynamic analysis approach for mining sandboxes.

\subsection{Taint Analysis}\label{sec:taint}

Taint analysis is a special type of static or dynamic analysis that aims to track data flows within programs~\cite{DBLP:conf/sigsoft/PauckBW18}. Typically, taint analysis is used to identify sensitive information leakage by detecting taint flow between ``sources'' and ``sinks''. In the context of Android apps, a data leak occurs when sensitive data, such as contact, or device ID, flows from a sensitive resource to a method that might \emph{sink} information to other peers, like sending a message. Taint analysis can present possible malicious data flow to malware detection tools or even for a human check, which can decide if the ``source-sink" relationship is or is not an unwanted behavior. Thereby, taint analysis monitors sensitive sources ``tainted" through the app by starting at a pre-defined point. 

In the Android context, sources are the APIs in which apps access sensitive information, called sensitive APIs. The analysis follows the data flow until it reaches a sink, like a method that sends SMS. It brings precise information about which data will be leaked~\cite{DBLP:conf/pldi/ArztRFBBKTOM14}. The Android SDK provides APIs that allow apps to send private data to other apps on the same device, or remote devices. As these APIs may lead to sensitive data leakage, they are security-critical and require special attention and control~\cite{DBLP:conf/osdi/EnckGCCJMS10}. (Listing~\ref{lst:sourceSink}) presents a simple data leakage example. In this example, the device information is captured at line 4 (source) and then leaked at line 9 (sink), by SMS transmission.


\begin{lstlisting}[caption={Simple Data Leakage},
      language=Java, basicstyle=\fontsize{8}{6}\selectfont\ttfamily,
      label={lst:sourceSink}]

1 > localObject2 = (TelephonyManager)getSystemService("phone");
2 > if (localObject2 != null)
3 > {
4 >  this.imei = ((TelephonyManager)localObject2).getDeviceId();//source
5 > }
6 > if ("".equals(this.destMobile)) {
7 >  getDestMobile();
8 > }
9 > sendSMS(this.destMobile, "imei:" + this.imei)//sink
\end{lstlisting}


Wei et al.~\cite{DBLP:conf/issta/HuangDMD15} propose a scalable taint analysis for Android apps that applies traditional taint analysis techniques with targeted optimizations specific to Android OS. FlowDroid~\cite{DBLP:conf/pldi/ArztRFBBKTOM14} improves the precision of traditional approaches by including context and flow sensitivity. A significant issue with taint analysis is the cost of the tool itself hampering the performance. FastDroid~\cite{DBLP:journals/compsec/ZhangTD21} mitigates this issue by introducing an intermediate light-weight abstraction to perform the analysis, called taint value graph (TVG). To improve efficiency and precision, FastDroid focuses on exploring the propagation of taint values, rather than the traditional data flow analysis. FastDroid constructs taint value graphs (TVGs) exploring taint values, then it extracts a subset of potential taint flows (PTFs) from it. FastDroid improves the analysis process by performing analysis only on (PTFs). In this paper we investigate the use of taint analysis to identify malicious behavior, by mining the source an sink pairs from distinct versions of an app.

\section{Background and related works}

%\kn{This section starts abrupt. We should have a line that says what concepts we introduce on a high level. Also, I feel "sandbox" itself should be one of the backgrounds and have a textbf after the introductory line.}

In this background session, we present information that is important to understand the remainder of this paper. As a first step, we introduce
Sandbox, its concept, and some sandbox security issues. After, we introduce Android Sandbox Mining technique, and how this approach can deal with malware detection at Android apps. Lastly, we present some concepts about Taint analysis.

\textbf{A Sandbox} is an isolated environment on an electronic device within which applications cannot affect other programs outside its boundaries, like the file system, the network, or other device data~\cite{DBLP:journals/peerj-cs/MaassSCS16}. It enables testing and execution of unsafe or untested code, possible malware, without worrying about the integrity of the electronic device that runs the application~\cite{DBLP:conf/esorics/BordoniCS17}. This need may arise in a variety of situations, such as when executing software input by untrusted users, in malware analysis, or even as a security mechanism in case a trusted system gets compromised \cite{DBLP:journals/peerj-cs/MaassSCS16}.
A sandbox environment should be able to shield the host machine or operating system from any damages caused by third party software. Thus, sandbox environment should have the minimum requirements to run programs (make sure the program will not impact resources outside the sandbox), and make sure it will never assign the program greater privileges than it should have, 
working with the principle of the least privilege, giving permissions to users according to their needs, \textit{i.e.}, giving them no more power than needed to successfully perform their task. This principle prevents escalating privileges and unauthorized access to resources, thereby improving the system's overall health. Within the Android ecosystem, least privilege is realized through sandboxing process, where apps never access the data of other apps, and an app just accesses user resources, like contacts and location, through specific APIs (Application Programming Interface), which are in-turn guarded by permissions.

Google Play Store is the primary market source for Android apps, and has a flexible policy regarding the process of publishing apps. Therefore, every month many Android apps are cleared from it because of issues related to spyware and other types of malware \cite{DBLP:conf/msr/WangLL0X18}. For security reasons, Google Play list each app with the requested permission. However, many malicious apps usually request more permissions than their APIs normally would require~\cite{DBLP:conf/ccs/FeltCHSW11}. Those permissions are presented to the user during the installation of a new app, since Android version 6, but most of the users are careless since they just want the end product.~\cite{DBLP:conf/soups/FeltHEHCW12} 
%\kn{Is there some citation or blog entry atleast that has shown this to be the real case with users?}

Nowadays, malware becomes more stealthy and hackers learn how to avoid anti-virus signature checks, by obfuscating the native code~\cite{DBLP:journals/corr/abs-2002-04540}
%\kn{Here we should cite the work of String hound (https://dl.acm.org/doi/10.1145/3320269.3384745)}
, calling Java libraries, or even by creating root exploits, since the native code is allowed to directly make syscalls. Another approach to rooting\footnote{https://en.wikipedia.org/wiki/Rooting(Android)} is making a side attack aimed at a benign app to make a syscall, exploiting its native code to get root access.


%It also guarantees an unbiased testing environment, ensuring the same pre-configured beginning status of the environment \kn{I dont understand what a pre-configured beginning status is}.

\textbf{The Android Mining Sandbox} concept is a sandboxing technique that consists of mining rules from an Android app, and use these rules to ensure system security. The sandboxing technique comprises of two steps. First, rules are mined and will compose the sandbox,
%\kn{I thought sandbox was an environment, now it is comprised of rules?}%
through test generator tools, that identifies sensitive Android API, called during their execution. 
%\kn{This sentence seems to miss something "what" happens through test generation tools.}
These tools investigate program behavior through resource accesses realized by theses APIs. The second stage ensures that resources not accessed, or accessed differently than first stage, are not accessible by the apps. So, if a malicious app requires access to resources, different from what was previously mined, the sandbox will prohibit this access.

Automatically mining software resources or components, to infer behavior is not new, and has been discussed before. For instance, Whaley et al.~\cite{DBLP:conf/issta/WhaleyML02} combine dynamic and static analysis for API mining and so infer program behavior based on an example use of a Java class. Ammons et al~\cite{DBLP:conf/popl/AmmonsBL02} propose a machine learning
approach, called specification mining, to discover temporal and data-dependence relationships that a program follows when interacting with an API or abstract data type.

%\kn{Please write one sentence here saying why test generation tools could solve the problem, and then list the related work. The term test generation comes out out nowhere.} 
The main purpose of test generation tool is to find bugs. However, it also can be used to explore program behavior, and thus assist in the task of building Sandboxes. Regarding test generating tools used for mining Sandboxes, Jamrozik et al ~\cite{DBLP:conf/icse/JamrozikZ16} proposed DroidMate, a test generation tool that implements a pseudo-random graphical user interface (GUI) exploration strategy, and was the first approach to leverage test generation to extract sandbox rules from apps. Li e tal.~\cite{DBLP:conf/icse/LiYGC17} proposed DroidBot, a test generator tool that explores sensitive resources access by apps, following a model-based exploration strategy. In their work, the authors present a comparison between DroidBot and Monkey~\cite{Monkey} regarding malware analysis, and showed that Droidbot is able to trigger an amount of sensitive behaviors higher than Monkey. Sensitive behaviors at Android context occurs when an Android app functionality can result in accessing or leaking of Android users sensitive data. Example of sensitive behaviors are file accesses and network access. Another test generator tool for Android is called Humanoid \cite{DBLP:conf/kbse/LiY0C19}, which is a Droidbot evolution. It's also a GUI test generation that learning how humans interact with Android apps. In contrary to random input generators, Humanoid use the learned model to generate human-like test inputs, and prioritize the possible interactions on a GUI, according their importance.



%~\kn{What is being compared with what. Is droidbot compared with monkey. If yes, then what is the proof  of concept example of using Droidbot? Something we have built. Or is the comparison between Droidbot and Monkey as an example of using droidbot?}. 



L Bao et al~.\cite{DBLP:conf/wcre/BaoLL18} had provided an important comparative study between five test generation tools that find malware by mining sandboxes techniques: DroidMate, Monkey, GUIRipper \cite{DBLP:conf/kbse/AmalfitanoFTCM12}, Puma \cite{DBLP:conf/mobisys/Hao0NHG14}, and Droidbot. This study indicates that these tools were efficient in identifying at most $70$\% of the malware in a specific dataset and also reports that after combining all test generator tools, it was possible to detect $75.49$\% of malicious behavior explored ($77$ among $102$). However, this study did not focus on the possible interference of static analysis in the final result, since this study used a instrumentation tool \cite{DBLP:conf/icsm/CaiR17a}, that also performs a static analysis of the apps 



\textbf{Taint analysis} is a special type of static or dynamic analysis that purpose is to track data flows within programs~\cite{DBLP:conf/sigsoft/PauckBW18}. It can identify sensitive information leakage detecting taint flow between ``source'' and ``sink''. In Android apps context, a data leak occurs when sensitive data, such as contact, or device ID, flows from a private source to public sinks, like the internet. Taint analysis can present possible malicious data flow to malware detection tools or even for a human check, that can decide if the ``source-sink" relationship is or is not an unwanted behavior. Thereby, taint analysis monitors sensitive source ``tainted" through the app by starting at a pre-defined point. 

In Android context, sources are the APIs in which apps access sensitive information, called sensitive APIs. The analysis follows the data flow until it reaches a sink, like a method that sends SMS. Finally, it brings exact information about which data will be leaked and where~\cite{DBLP:conf/pldi/ArztRFBBKTOM14}. The Android SDK provides APIs that allow apps to send private data to other apps on the same device, or remote devices. As these APIs may lead to sensitive data leakage, they are security-critical and require special attention and control~\cite{DBLP:conf/osdi/EnckGCCJMS10}. (Listing~\ref{lst:sourceSink}) presents a simple data leakage example. In this example, the device information is captured at line 4 (source) and then leaked at line 9 (sink), by SMS transmission.


\begin{lstlisting}[caption={Simple Data Leakage},
      language=Java, basicstyle=\fontsize{8}{6}\selectfont\ttfamily,
      label={lst:sourceSink}]

1 > localObject2 = (TelephonyManager)getSystemService("phone");
2 > if (localObject2 != null)
3 > {
4 >  this.imei = ((TelephonyManager)localObject2).getDeviceId();//source
5 > }
6 > if ("".equals(this.destMobile)) {
7 >  getDestMobile();
8 > }
9 > sendSMS(this.destMobile, "imei:" + this.imei)//sink
\end{lstlisting}


Wei et al.~\cite{DBLP:conf/issta/HuangDMD15} propose a scalable taint analysis for Android apps that applies traditional taint analysis techniques with targeted optimizations specific to Android OS. Flowdroid~\cite{DBLP:conf/pldi/ArztRFBBKTOM14} improves on precision of traditional approaches by including context and flow sensitivity. A significant issue with taint analysis is the cost of the tool itself hampering the performance. FastDroid~\cite{DBLP:journals/compsec/ZhangTD21} mitigates this issue by introducing an intermediate light-weight abstraction to perform the analysis, called taint value graph (TVG). To improve the efficiency and precision, FastDroid focuses on exploring the propagation of taint values, rather than the traditional data flow analysis. FastDroid constructs taint value graphs (TVGs) exploring taint values, then it extracts a subset of potential taint flows (PTFs) from it. FastDroid improves the analysis process by performing analysis only on (PTFs).